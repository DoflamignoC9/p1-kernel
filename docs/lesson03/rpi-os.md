# 3.1: Interrupts

## Objectives

A baremetal program prints out messages as driven by periodic interrupts from a hardware timer

1. Exception/interrupt vectors

2. Handling interrupts

3. Program hardware timers


**Terms**

interrupts == irq



## Background: interrupts & exceptions in ARM64

We know that: interrupts are asynchronous while exceptions are synchronous. However in ARM64 lingo, interrupts are a special kind of exceptions. x86 has its own lingo. When we refer to ARM's broad definition of "exceptions" we will be explicit. In general discussion of OS designs, however, we will stick to our differentiation between interrupts vs exceptions. 

### Exception types

ARM64 defines 4 types of exceptions. **We will focus the former two**. 

* **Synchronous exception** Exceptions of this type are always caused by the currently executed instruction. For example, you can use `str` instruction to store some data at an unexistent memory location. In this case, a synchronous exception is generated. Synchronous exceptions also can be used to generate a "software interrupt". Software interrupt is a synchronous exception that is generated on purpose by `svc` instruction. We will use this technique in lesson 5 to implement system calls.
* **IRQ (Interrupt Request)** Those are normal interrupts. They are always asynchronous, which means that they have nothing to do with the currently executed instruction.  In contrast to synchronous exceptions, they are always not generated by the processor itself, but by external hardware.
* **FIQ (Fast Interrupt Request)** This type of exception is called "fast interrupts" and exist solely for the purpose of prioritizing exceptions. It is possible to configure some interrupts as "normal" and other as "fast". Fast interrupts will be signaled first and will be handled by a separate exception handler. Linux doesn't use fast interrupts and we also are not going to do so.
* **SError (System Error)** Like `IRQ` and `FIQ`, `SError` exceptions are asynchronous and are generated by external hardware. Unlike `IRQ` and `FIQ`, `SError` always indicates some error condition. [Here](https://community.arm.com/processors/f/discussions/3205/re-what-is-serror-detailed-explanation-is-required) you can find an example explaining when `SError` can be generated.

### Exception vectors

<!---Each exception type needs its own handler. Also, separate handlers should be defined for each different execution state, in which exception is generated. There are 4 execution states that are interesting from the exception handling standpoint. If we are working at EL1 those states can be defined as follows:-->

An exception handler == an exception vector == a piece of code the CPU will execute when a specific exception happens. "*These would normally be branch instructions that direct the core to the full exception handler.*" -- ARM. In some other architectures an exception vector could be an address. Note the subtle difference. 

Each EL has its own vector table. Here we focus on EL1. The kernel must provide exception handlers to be executed at EL1 in order to handle exceptions from EL0 or EL1. 

These should be handlers  for *each* exception type above (SError, fiq, irq, and sync) and for *each* of the four execution states of the CPU:

1. **EL1t** Exception is being taken at EL1 (i.e. *exception happens when CPU is at EL1*) while stack pointer was shared with EL0. This happens when `SPSel` register holds the value `0`.  Recall that `SPSel` is part of CPU PSTATE. 
1. **EL1h** Exception is being taken at EL1 at the time when dedicated stack pointer was allocated for EL1. This means that `SPSel` holds the value `1`. **This is the mode that we are currently using.**
1. **EL0_64** Exception is taken from EL0 executing in 64-bit mode. This experiment will not deal with EL0. Spoiler: this corresponds to exceptions in 64-bit user programs. 
1. **EL0_32** Exception is taken from EL0 executing in 32-bit mode. This experiment will not deal with EL0 or 32-bit mode. Spoiler: this corresponds to exceptions in 32-bit user programs. 

> "The t and h suffixes are based on the terminology of *thread* and *handler*, introduced in ARMv7-M." -- ARM

In total, for EL1 the kernel needs to define 16 exception handlers (4 types X 4 execution states) 

### ARM64 vector table

**Each exception vector** (or handler): a continuous sequence of instructions responsible for handling a particular exception. Each exception vector can occupy`0x80` bytes maximum. This is not much, but nobody prevents us from jumping to some other memory location from an exception vector. 

**The vector table**: An array of exception vectors. Note each EL has its own table. 

Here is a short, good [reference](https://developer.arm.com/docs/100933/0100/aarch64-exception-vector-table). The structure of a vector table is defined in `Table D1-7 Vector offsets from vector table base address` at page 1876 of the [AArch64-Reference-Manual](https://developer.arm.com/docs/ddi0487/ca/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile). 

## Code Walkthrough 

### Exception vectors, tables, etc.

Everything related to exception handling is defined in [entry.S](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/entry.S). The code mimics what the ARM64 Linux kernel does. 

Why named "entry"? Because in a full-fledged kernel, exception/irq handlers are where user programs enter the kernel for execution. Although this experiment is not building such a kernel, we follow the convention. 

The first macro [ventry](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/entry.S#L12) and it is used to create entries in the vector table.

```
    .macro    ventry    label
    .align    7
    b    \label
    .endm
```

As suggested above: for code clarity, we are not going to handle exceptions right inside the exception vector. Instead, we make each vector a branch instruction that jumps to a label provided for the macro as `label` argument.

<!-- Instead, we jump to a label that is provided for the macro as `label` argument. -->

We need `.align 7` because all exception vectors should be spaced at `0x80` bytes (2^7) one from another. 

Vector table is defined [here](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/entry.S#L64) and it consists of 16 `ventry` definitions. 

#### Making CPU aware of the vector table

Ok, now we have prepared the vector table, but the processor doesn't know where it is located and therefore can't use it. In order for the exception handling to work, we must set `vbar_el1` (Vector Base Address Register) to the vector table address. This is done [here](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/irq.S#L2).

```
.globl irq_vector_init
irq_vector_init:
    adr    x0, vectors        // load VBAR_EL1 with virtual
    msr    vbar_el1, x0        // vector table address
    ret
```

#### A simple handler for invalid exceptions

In this experiment we are only interested in handling `IRQ` from `EL1h`. Yet, our kernel  defines all 16 handlers for EL1. This is for debugging ease: we want to print out meaningful message in case our kernel triggers some other exceptions due to our programming mistakes. 

> Note again: all these handlers are to be executed at EL1. The exceptions come from either EL0 or EL1. 

We name all the handlers that are NOT suppos  ed to be trigged  with a `invalid` postfix. We implement these handlers using a [handle_invalid_entry](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/entry.S#L3) macro:

```
    .macro handle_invalid_entry type
    kernel_entry
    mov    x0, #\type
    mrs    x1, esr_el1
    mrs    x2, elr_el1
    bl    show_invalid_entry_message
    b    err_hang
    .endm
```

The first line invokes a macro `kernel_entry` which is the first few instructions the kernel should execute in handling an exception/interrupt (recall the term "entry"). We will discuss it below.

Then we call [show_invalid_entry_message](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/irq.c#L34) and prepare 3 arguments for it. The arguments are passed in 3 registers: x0, x1, and x3. 

* x0: the exception type. The value comes from the argument to this macro. It can take one of [these](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/include/entry.h#L6) values defined by our kernel code. It tells us exactly which exception handler has been executed.
* x1: detailed information about what causes the exception. The value comes from `esr_el1` register.  `ESR` stands for Exception Syndrome Register. EL1 means "when an exception taken to EL1", i.e. when the exception is handled at EL1. Note: in this experiment our kernel runs at EL1 and when an interrupt happens it is handled at EL1. Read the [ref](https://developer.arm.com/docs/ddi0595/b/aarch64-system-registers/esr_el1) again. 
* x2: the address of the instruction being executed when the exception happens. The value comes from the  `elr_el1` as described earlier. For synchronous exceptions, this is the instruction that causes the exception; for irqs (asynchronous), this is the instruction completed right before irq happens. Again, EL1 indicates that "*when taking an exception to EL1, (this reg) holds the address to return to.*" (ARM)

The code next invokes `show_invalid_entry_message`  function, which prints all this information to UART. Returning from the function, the code executes in an infinite loop and we are done. 

#### kernel_entry & exit

To handle *valid* exceptions (timer interrupts in our case), the kernel needs to save & restore the *context* of the "normal" execution, i.e. switching from the normal execution to the exception handler, executing it, and resuming the execution being interrupted. In other words, after the exception handler, we want all general purpose registers to have the same values they had before the exception was generated. 

Why does NOT the above handler `handle_invalid_entry` do so? Because it ends with an inf loop and never returns. 

Back to `kernel_entry`. This is the first thing to do in handling an exception: saving the processor state, notably CPU registers. The [kernel_entry](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/entry.S) simply stores registers `x0 - x30` to the stack. Note it first subtracts from `sp` the size of total stored registers (#S_FRAME_SIZE) and then fills the space. 

According to `kernel_entry`, there is  [kernel_exit](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/entry.S#L37) to be called as the last thing of an exception handler. `kernel_exit` restores processor state by copying back the values of `x0 - x30` registers. Note the order which exactly mirrors that of `kernel_entry` otherwise we will see wrong register values. Finally `kernel_exit` executes `eret`, which returns to the normal execution. 

```
el1_irq:
	kernel_entry 
	bl	handle_irq
	kernel_exit 
```

Note: general purpose registers are not the only thing to be saved for `kernel_entry/exit`. Doing so is good for our simple kernel for now. More on them in subsequent experiments. 

### Working with interrupts

<!--- need an overall figure: how irq connected -->

#### Configuring interrupt controller 

Interrupts are generated by IO devices, go through the irq controller, and eventually arrive the CPU. The CPU can program the irq controller to enable/disable specific interrupts. By disabling an irq source, the CPU will not lose any irq from the device, but just defer receiving irq until CPU re-enables the irq source. The CPU can also read from the irq controller which IO devices have pending interrupts, meaning that the IO devices need attention. 

Bcm2837, the SoC for Rpi3, has its own interrupt controller that is described on page 109 of [BCM2837 ARM Peripherals manual](https://github.com/raspberrypi/documentation/files/1888662/BCM2837-ARM-Peripherals.-.Revised.-.V2-1.pdf).
Because of the hardware quirks (e.g. many irqs routed from GPU to CPU), the interrupt controller organizes irq sources into three groups and has registers for controlling/checking individual groups. 
> Be aware of their weird naming: they are called "Basic" (irqs routed to ARM, i.e. CPU), "1", and "2" (irqs routed from GPU to CPU). For example, `IRQ basic pending`, `IRQ pending 1`, `IRQ pending 2`.  The SoC doc has more dirty details. 

We are only interested in timer interrupts. `BCM2837 ARM Peripherals manual` (i.e. the SoC doc), page 113 states that irq #1 and #3 are from the system timer. These irq sources belong to the irq group 1, which can be enabled using [ENABLE_IRQS_1](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/include/peripherals/irq.h#L10). So here is the [function](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/irq.c#L29) that enables system timer IRQ at #1.

<!--- According to the documentation, interrupts are divided into 2 banks. The first bank consists of interrupts `0 - 31`, each of these interrupts can be enabled or disabled by setting different bits of `ENABLE_IRQS_1` register. There is also a corresponding register for the last 32 interrupts - `ENABLE_IRQS_2` and a register that controls some common interrupts together with ARM local interrupts - `ENABLE_BASIC_IRQS` (We will talk about ARM local interrupts in the next chapter of this lesson). --->

<!--- The Peripherals manual, however, has a lot of mistakes and one of those is directly relevant to our discussion. Peripheral interrupt table (which is described at page 113 of the manual) should contain 4 interrupts from system timer at lines `0 - 3`. From reverse engineering Linux source code and reading [some other sources](http://embedded-xinu.readthedocs.io/en/latest/arm/rpi/BCM2835-System-Timer.html) I was able to figure out that timer interrupts 0 and 2 are reserved and used by GPU and interrupts 1 and 3 can be used for any other purposes. So here is the [function](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/irq.c#L29) that enables system timer IRQ number 1.--->

```
void enable_interrupt_controller()
{
    put32(ENABLE_IRQS_1, SYSTEM_TIMER_IRQ_1);
}
```

#### Masking/unmasking interrupts

From time to time, the kernel must mask/unmask ALL interrupts, so that the code regions will never be interrupted. For example, what happens if an interrupt occurs right in the middle of `kernel_entry` macro? The processor state would be corrupted. 

Upon entry to ANY exception/interrupt, the processor automatically masks all interrupts so that the kernel can save the CPU state atomically. The kernel then unmasks appropriate interrupts it wants to handle during the execution of the interrupt handler. Right before exiting the exception/interrupt handling (`eret`), the kernel masks all interrupts again for atomic CPU state restore. 

<!-- Many people mistakenly think that interrupts must be masked for the whole duration of the exception handler. This isn't true - it is perfectly legal to unmask interrupts after you saved processor state and therefore it is also legal to have nested interrupts. We are not going to do this right now, but this is important information to keep in mind. -->

Note: it is perfectly legal to have nested interrupts, i.e. handling another interrupt in the middle of an interrupt handler. Nested interrupts are NOT common: for simple designs, many kernels intentionally keep interrupt handlers very short so they can mask interrupts throughout an interrupt handler without delaying interrupts too much. However, handling interrupts in exception handlers is VERY common. Syscalls are executed as exception handlers and the kernel must be responsive to interrupts in executing syscalls. 

The [following two functions](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/irq.S#L7-L15) mask and unmask interrupts.

```
.globl enable_irq
enable_irq:
    msr    daifclr, #2
    ret

.globl disable_irq
disable_irq:
    msr    daifset, #2
        ret
```

ARM processor state (PSTATE) has 4 bits holding mask status for different types of interrupts. 

* **D**  Masks debug exceptions. These are a special type of synchronous exceptions. For obvious reasons, it is not possible to mask all synchronous exceptions, but it is convenient to have a separate flag that can mask debug exceptions.
* **A** Masks `SErrors`. It is called `A` because `SErrors` sometimes are called asynchronous aborts.
* **I** Masks `IRQs`
* **F** Masks `FIQs`

Now you can probably guess why registers that are responsible for changing interrupt mask status are called `daifclr` and `daifset`. Those registers set and clear interrupt mask status bits in the processor state.

Why do we use constant value `2` in both of the functions? This is because we only want to set and clear the second (`I`) bit.


#### The IRQ handler

We have a single, common exception handler for handling all `IRQs`. This handler is defined [here](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/irq.c#L39).

```
void handle_irq(void)
{
    unsigned int irq = get32(IRQ_PENDING_1);
    switch (irq) {
        case (SYSTEM_TIMER_IRQ_1):
            handle_timer_irq();
            break;
        default:
            printf("Unknown pending irq: %x\r\n", irq);
    }
}
```

In the handler, we need a way to figure out what device was responsible for generating an interrupt. Interrupt controller can help us with this job: it has `IRQ_PENDING_1` register that holds interrupt status for interrupts `0 - 31`. Using this register we can check whether the current interrupt was generated by the timer or by some other device and call device specific interrupt handler. Note, that multiple interrupts can be pending at the same time. That's why each device specific interrupt handler must acknowledge that it completed handling the interrupt and only after that interrupt pending bit in `IRQ_PENDING_1` will be cleared. Because of the same reason, for a production ready OS you would probably want to wrap switch construct in the interrupt handler in a loop: in this way, you will be able to handle multiple interrupts during a single handler execution. 

### Arm' generic hardware timer 

We use the Arm generic timer, which is part of Arm64 core design (i.e. not defined by SoC). This is nice, as the generic timers exist for all Armv8 CPUs. Your experiences will apply to other Armv8 SoCs as well. Arm's [official webpage](https://developer.arm.com/architectures/learn-the-architecture/generic-timer/single-page) documents (ARM062-1010708621-30) the use of generic timers. 

The following figure shows the generic timer hardware. In a nutshell, a global, chip-level hardware counter (i.e. "System Counter") drives per-core timer instances. As hardware boots, System Counter keeps incrementing, i.e. "free running". Software can read the current System Counter. But System Counter alone does not trigger interrupts. Software must program the timers so that they interrupt corresponding CPU cores at specific time intervals. Note: PE means CPU cores.

<img src="images/1_and_3_System_counter_ST1.png" width="400" />

As our kernel only deals with one core, we focus on one timer instance. 

How should the kernel program the timer? The timer provides two core registers (among others) as two **alternative** ways for programming the same timer. They are intuitive: 

* CVAL, a 64-bit comparator. Roughly, this means a programmable "threshold" for System Counter: 
* Example: The kernel writes a value X to CVAL. When System Counter exceeds X, an interrupt will be triggered.
* TVAL, a 32-bit timer value. Roughly, this means a programmable "delta" for System Counter: 
  * Example: The kernel writes a value X to TVAL. The hardware updates CVAL +=  the Current System Counter + TVAL. 

These suffice for our kernel experiment. Beyond them, TVAL has another less intuitive, "countdown" function (not used in this experiment; good to know). Since last write by software, TVAL decrements as System Counter increments. The moment TVAL counts down to 0 is when an interrupt fires. After that, TVAL will keep counting down to a minus value. 

To summarize: If software needs a timer event in X ticks of the clock, software can write X to TVAL periodically. Alternatively, if software wants an event when the system count reaches Y, software can write Y to CVAL. If software wants to know the remaining ticks until the next interrupt, software reads from TVAL.

#### Initialize timer (timer.S)

We turn on timer interrupt and enable the timer. 

```
gen_timer_init:
	mov x0, #1
	msr CNTP_CTL_EL0, x0
	ret
```

This writes 1 to the control register (`CNTP_CTL_EL0`) of **the EL1 physical timer**. See [here](https://developer.arm.com/docs/ddi0595/latest/aarch64-system-registers/cntp_ctl_el0) for the register definition. 

> About timer register naming: 
>
> CTL: control register; 
>
> CNTP_XXX_EL0: the EL1 physical timer. Why _EL0? I guess it means that the timer is accessible to both EL1 and EL0. See the table below. 

| **Register**         | **Purpose**      |
| -------------------- | ---------------- |
| `<timer>_CTL_EL<x>`  | Control register |
| `<timer>_CVAL_EL<x>` | Comparator value |
| `<timer>_TVAL_EL<x>` | Timer value      |

| **Timer**                     | **Register prefix** | **`EL<x>`** |
| ----------------------------- | ------------------- | ----------- |
| EL1 physical timer            | CNTP                | `EL0`       |
| EL1 virtual time              | CNTV                | `EL0`       |
| Non-secure EL2 physical timer | CNTHP               | `EL2`       |
| Non-secure EL2 virtual timer  | CNTHV               | `EL2`       |
| EL3 physical timer            | CNTPS               | `EL1`       |
| Secure EL2 physical timer     | CNTHPS              | `EL2`       |
| Secure EL2 virtual timer      | CNTHVS              | `EL2`       |

#### Turn on timer interrupt at the CPU core

We have to deal with yet another Rpi3 quirk. The Arm generic timer IRQs are wired to a per-core interrupt controller/register. For core 0, this is `TIMER_INT_CTRL_0` at 0x40000040; bit 1 is for physical timer at EL1 (CNTP). This register is documented in the [manual](https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2836/QA7_rev3.4.pdf) of BCM2836 (search for "Core timers interrupts"). Note the manual is NOT for the BCM2837 SoC used by Rpi3. I have no idea how community figured this out. 

```
void enable_interrupt_controller()
{
    // Enables Core 0 Timers interrupt control for the generic timer 
    put32(TIMER_INT_CTRL_0, TIMER_INT_CTRL_0_VALUE);
}
```

#### Handing timer interrupts

The kernel gets an irq. If it comes from the timer, the kernel resets the timer for firing the next interrupt. 

```
void handle_irq(void) {
    // Each Core has its own pending local intrrupts register
    unsigned int irq = get32(INT_SOURCE_0);
    switch (irq) {
        case (GENERIC_TIMER_INTERRUPT):
            handle_generic_timer_irq();
            break;
    ...
```

The EL1h exception handler invokes the above function. The function reads `INT_SOURCE_0` (0x4000:0060, search for "Core interrupt sources" in the BCM2836 [manual](https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2836/QA7_rev3.4.pdf)), where bit 1 is for our CNTP timer. So the function checks if that bit is set. 

#### Reset timer (timer.S)

The kernel writes a delta value (1<<24) to TVAL, requesting an interrupt to fire after 1<<24 ticks. 

```
gen_timer_reset:
    mov x0, #1
	lsl x0, x0, #24 
	msr CNTP_TVAL_EL0, x0
    ret
```

### Other timers on Rpi3

There are other timers on Rpi3 which you may see from various online blogs/tutorials/forums. The information can be very confusing. The naming of timers does not help. I list them below together with Arm generic timers described above. I suggest you stay away from other timers because the experience will not be as useful. 

| Name              | Implemented by | IRQ                                                    | QEMU support? (v5.0 )                                        | Phys Addr | Document                             |
| ----------------- | -------------- | ------------------------------------------------------ | ------------------------------------------------------------ | --------- | ------------------------------------ |
| System Timer      | Broadcom?      | Global. In GPU irq space.                              | Implemented as bcm2835_systmr. However free running and [cannot generate irq](https://lists.sr.ht/~philmd/qemu/patches/8811
). | 3f003000  | BCM2837                              |
| ARM timer         | Arm ip (sp804) | Global. In Arm core's private irq space ("Basic irqs") | Unimplemented. See QEMU code bcm2835_peripherals.c           | 3f00b400  | BCM2836                              |
| Local timer       | Broadcom?      | Per core.                                              | [Partially implemented](https://forum.osdev.org/viewtopic.php?f=2&t=33537). Can generate trigger irq but readback seems unsupported. | 40000034  | BCM2836                              |
| Arm generic timer | Part of armv8  | Per core.                                              | Implemented                                                  | 40000040  | Armv8 doc +  BCM2836 for IRQ routing |

<!--- del the following ---> 

#### Programming the BCM system timer

Raspberry Pi system timer is a very simple device. It has a counter that increases its value by 1 after each clock tick. It also has 4 interrupt lines that connect to the interrupt controller(so it can generate 4 different interrupts)  and 4 corresponding compare registers. When the value of the counter becomes equal to the value stored in one of the compare registers the corresponding interrupt is fired. That's why, before we will be able to use system timer interrupts, we need to initialize one of the compare registers with a non-zero value, the larger the value is - the later an interrupt will be generated. This is done in [timer_init](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/timer.c#L8) function.

```
const unsigned int interval = 200000;
unsigned int curVal = 0;

void timer_init ( void )
{
    curVal = get32(TIMER_CLO);
    curVal += interval;
    put32(TIMER_C1, curVal);
}
```

The first line reads current counter value, the second line increases it and the third line sets the value of the compare register for the interrupt number 1. By manipulating `interval` value you can adjust how soon the first timer interrupt will be generated.

Finally, we got to the timer interrupt handler. It is actually very simple.

```
void handle_timer_irq( void )
{
    curVal += interval;
    put32(TIMER_C1, curVal);
    put32(TIMER_CS, TIMER_CS_M1);
    printf("Timer iterrupt received\n\r");
}
```

Here we first update compare register so that that next interrupt will be generated after the same time interval. Next, we acknowledge the interrupt by writing 1 to the `TIMER_CS` register. In the documentation `TIMER_CS` is called "Timer Control/Status" register. Bits [0:3] of this register can be used to acknowledge interrupts coming from one of the 4 available interrupt lines.





### Why timer

There is one device that is particularly useful in operating system development: system timer. It is a device that can be configured to periodically interrupt a processor with some predefined frequency. One particular application of the timer that it is used in the process scheduling. A scheduler needs to measure for how long each process has been executed and use this information to select the next process to run. This measurement is based on timer interrupts.



### Conclusion

The last thing that you might want to take a look at is the [kernel_main](https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson03/src/kernel.c#L7) function where all previously discussed functionality is orchestrated. After you compile and run the sample it should print "Timer interrupt received" message after an interrupt is taken. Please, try to do it by yourself and don't forget to carefully examine the code and experiment with it.

**Previous Page**

2.3 [Processor initialization: Exercises](../../docs/lesson02/exercises.md)

**Next Page**

3.2 [Interrupt handling: Low-level exception handling in Linux](../../docs/lesson03/linux/low_level-exception_handling.md)